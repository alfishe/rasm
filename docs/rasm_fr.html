
<!DOCTYPE html>
<html>
	<head>
		<title>Rasm assembler v0.96 documentation</title>
		<meta name="keywords" lang="en-us" content="Z80, assembler, rasm, Amstrad">
		<meta name="keywords" lang="fr" content="Z80, assembleur, rasm, Amstrad">
		<meta name="author" content="Edouard BERGE">
		<meta name="version" content="0.96">
		<meta name="licence" content="MIT">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style type="text/css">
			body {background-color:#FFF; color:#111;}
			code {color:#118;font-weight:lighter;}
			td,th {padding:3px;}
			A:link, A:visited, A:active {color:#114;text-decoration:none;}
			A:active {text-decoration:underline;}
			A:hover {color:#226;text-decoration:underline;}
			#titre {display:block;width:auto;font-weight:900;text-align:center;padding:15px;border:1px solid black;line-height:0;}
			#licence {font-weight:lighter;padding:20px;border:1px solid black;}
			.titre1 {clear:both;font-weight:bolder;margin:25px;text-decoration:underline;}
			.titre2 {clear:both;font-weight:bold;margin:25px;}
			.titre3 {clear:both;font-weight:bold;margin:25px;padding-left:30px;}
			.invisibletable {border:0px solid transparent;padding:10px;}
			.visibletable {border:1px solid black;margin:5px;border-collapse: collapse;}
			.multicol {column-width: auto; column-count: auto; -moz-column-width: auto; -moz-column-count: auto; -webkit-column-width: auto; -webkit-column-count: auto; -webkit-column-gap: 20px; -moz-column-gap: 20px; column-gap: 20px; }
		</style>
	</head>
	<body>
	<div id="main">
		<div id="titre"><h2>RASM v0.96</h2><br><h4>roudoudou Z80 assembler</h4></div>
		<!-- ****************************************************** -->
		<!--         T A B L E   D E S   M A T I E R E S            -->
		<!-- ****************************************************** -->
		<div id="index" class="multicol"><div class="titre1"><h1>Table des matières<h1></div>
			<a href="#Introduction">Introduction</a><br>
			<a href="#Fonctionnalites">Fonctionnalités</a><br>
			<a href="#Installation">Installation</a><br>
			<a href="#Compilation">Compilation</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#CompilationLinux">Compilation Linux</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#CompilationWindows">Compilation Windows</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#CompilationMorphos">Compilation MorphOS</a><br>

			<a href="#Comportement">Comportement</a><br>
			<a href="#Commandline">Ligne de commande</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#FileOpt">Options de noms de fichiers</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#ExportOpt">Options d'export sur fichier EDSK</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#ExportSna">Options d'export sur fichier snapshot</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#SymbOpt">Options de symboles</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#Depend">Options de dépendances</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#CompOpt">Options de compatibilité</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#DevOpt">Options de développeur (usage interne)</a><br>

			<a href="#Syntax">Format du code source</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#GeneraliteFormat">Généralité</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#CommentaireFormat">Commentaires</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#LiteraleFormat">Valeurs litérales</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#CaractereFormat">Caractères autorisés</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#FichierFormat">Fichiers</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#LabelFormat">Labels</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#ExpLocalLabelFormat">Labels de proximité</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#LocalLabelFormat">Labels locaux</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#LabelTagFormat">Tags spécifiques aux labels ou structures</a><br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#TagBANK">{BANK}</a><br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#TagPAGE">{PAGE}</a><br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#TagPAGESET">{PAGESET}</a><br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#TagSIZEOF">{SIZEOF}</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#Coloration">Coloration syntaxique dans VIM</a><br>

			<a href="#Expressions">Expressions</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#Operateurs">Opérateurs de calcul</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#Priorites">Priorité d’exécution des opérateurs</a><br>

			<a href="#Variables">Variables</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#Statiques">Statiques</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#Dynamiques">Dynamiques</a><br>

			<a href="#DirectivesM">Directives mémoires</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#ALIGN">ALIGN</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#BANK">BANK</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#BANKSET">BANKSET</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#LIMIT">LIMIT</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#ORG">ORG</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#PROTECT">PROTECT</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#WRITE">WRITE DIRECT</a><br>

			<a href="#DirectivesD">Directives de définition de données</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#CHARSET">CHARSET</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#DEFB">DEFB</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#DEFW">DEFW</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#DEFI">DEFI</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#DEFR">DEFR</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#DEFS">DEFS</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#EQU">EQU</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#STR">STR</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#STRUCT">STRUCT</a><br>

			<a href="#DirectivesI">Directives d'import et de compression</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#INCLUDE">INCLUDE</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#INCBIN">INCBIN</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#INCL48">INCL48, INCL49, INCLZ4, INCZX7, INCEXO</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#LZ">LZ48, LZ49, LZ4, LZX7, LZEXO</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#LZCLOSE">LZCLOSE</a><br>

			<a href="#DirectivesC">Directives de code conditionnel</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#ASSERT">ASSERT</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#IFTHEN">IF IFNOT THEN ELSEIF ELSE ENDIF</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#IFDEF">IFDEF, IFNDEF</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#IFUSED">IFUSED, IFNUSED</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#MACRO">MACRO</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#PRINT">PRINT</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#FAIL">FAIL</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#REPEAT">REPEAT, REND, UNTIL</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#SWITCH">SWITCH, CASE, DEFAULT, BREAK, ENDSWITCH</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#STOP">STOP</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#WHILE">WHILE, WEND</a><br>

			<a href="#DirectivesF">Directives de sortie fichier</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#AMSDOS">AMSDOS</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#BREAKPOINT">BREAKPOINT</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#BUILDCPR">BUILDCPR</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#BUILDSNA">BUILDSNA</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#RUN">RUN</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#SAVE">SAVE</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#SETCPC">SETCPC</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#SETCRTC">SETCRTC</a><br>

			<a href="#DirectivesU">Directives de compatibilité</a><br>
			&nbsp;&nbsp;&nbsp;- <a href="#LIST">LIST, NOLIST, LET</a><br>

			<a href="#Instructions">Jeu d'instruction</a><br>
			<a href="#Limitations">Limitations</a><br>
			
		</div>
		<!-- ****************************************************** -->
		<!--                C H A P I T R E S                       -->
		<!-- ****************************************************** -->
		<div id="Introduction"><div class="titre1">Introduction</div>
			Lors de la création de ma démo <a href="http://www.pouet.net/prod.php?which=72279" target=_top>CRTC³</a>, les assembleurs existants ont tous rapidement montré leurs limites, que ce soit en termes de rapidité d'assemblage ou de fonctionnalités offertes. En effet, le projet final analyse plus de 250'000 mots (hors commentaires), 35'000 labels et 60'000 expressions. Il fallait donc en priorité un assembleur qui soit rapide et lui ajouter au minimum des fonctionnalités que n'ont pas les autres: support natif des cartouches, disquettes ou snapshot Amstrad, espaces mémoires multiples, calculs flottants, compressions les plus courantes intégrées (afin de s'éviter par exemple de fastidieux export/imports de symboles), etc.<br><br>
			
			Il y a 18 ans, j'avais programmé un petit assembleur. Je ne m'en étais pas servi à l'époque car il était limité. J'en ai néanmoins repris le principe d'assemblage mono-passe.<br><br>
			
			Rasm utilise des concepts éprouvés (arbres de Merkel, nombreux caches, allocations groupées) et surtout une conception linéaire (la récursivité tue les performances). Les performances d'assemblage sont extrêmement rapides en conditions réelles sur de gros projets, si bien que certaines optimisations n'ont même pas été faites.<br><br>
			
			Aujourd'hui Rasm est utilisé sur plusieurs gros projets:<br>
			&nbsp;- Ghost'n Goblins par Golem13<br>
			&nbsp;- <a href="" target=_top>Arkos Tracker II</a> par Targhan de façon intégrée au logiciel<br>
			<br>
			<br>
			Rasm est diffusé sous licence <a href="#Licence">MIT</a>.
		</div>
		<div id="Fonctionnalites"><div class="titre1">Fonctionnalités</div>
			<ul>
			<li>compilation ultra-rapide</li>
			<li>intégration des compresseurs les plus courants</li>
			<li>export au format binaire, cartouche, disquettes, snapshot...</li>
			<li>export/import des symboles</li>
			<li>contrôle automatique des zones mémoires contre l'écrasement</li>
			<li>espaces mémoires illimités où les labels/variables sont partagées</li>
			<li>gestion dédiée des ROM et extensions mémoires</li>
			<li>absolument toutes les instructions sont supportées</li>
			<li>macros, code conditionnel, boucles illimités, labels locaux, switch/case</li>
			<li>calculs internes en double précision et arrondi correct</li>
			<li>compatibilité optionnelle avec Maxam ou AS80</li>
			</ul>
		</div>
		<div id="Installation"><div class="titre1">Installation</div>
			Rasm est un exécutable indépendant, il s'utilise tel que, sans installation aucune.
		</div>
		<div id="Compilation"><div class="titre1">Compilation</div>
			<div id="CompilationLinux"><div class="titre2">Compilation Linux avec GCC ou Clang</div>
				<code>
				cc rasm_v096.c -O2 -lm -lrt -march=native<br>
				mv a.out rasm<br>
				strip rasm
				</code>
			</div>
			<div id="CompilationWindows"><div class="titre2">Compilation Windows avec Visual Studio</div>
				<code>
				cl.exe rasm_v096.c -O2
				</code>
			</div>
			<div id="CompilationDOS"><div class="titre2">Compilation DOS ou Windows 32 bits avec Watcom</div>
				<code>
				# do not use -s or -ox option, this will cause a fatal stack issue
				wcl386.exe rasm_v096.c -6r -6s -fp6 -d0 -k4000000 -obmiler
				</code>
			</div>
			<div id="CompilationMorphos"><div class="titre2">Compilation MorphOS (ixemul)</div>
				<code>
				ppc-morphos-gcc-5 -O2 -c -o rasm rasm_v096.c<br>
				strip rasm
				</code>
			</div>
		</div>
		<div id="Comportement"><div class="titre1">Comportement de Rasm (généralités)</div>
			Rasm essaie d'être simple d'utilisation. En ce sens il va produire des noms de fichier par défaut, déterminer la quantité de mémoire à enregistrer ou même créer un fichier cartouche si les banques ROM ont été sélectionnées lors de l'assemblage.<br><br>

			Rasm permet l'utilisation de plusieurs <a href="#ORG">ORG</a> au sein d'un même espace mémoire. Par contre il n'autorise pas de ré-écrire sur les mêmes adresses mémoire. À chaque nouveau ORG, Rasm contrôle qu'aucune zone de code écrite ne se chevauche.<br><br>

			Si vous avez besoin de générer plusieurs morceaux de code à la même adresse, vous avez deux possibilités. Soit vous utilisez le deuxième paramètre de la directive ORG pour écrire ce code ailleurs, soit vous pouvez créer à tout moment un nouvel espace mémoire avec la directive <a href="#BANK">BANK</a><br><br>

			Dans la mesure du possible, Rasm essaie d'afficher des messages d'erreurs afin de vous orienter vers la solution syntaxique convenable.<br><br>

			Rasm va d'abord pré-traiter le fichier à assembler pour enlever les espaces superflus, les commentaires, vérifier les quotes, que les caractères utilisés soient conformes et enfin transformer certaines instructions en d'autres pour convenance interne. Par exemple les opérateurs Maxam XOR, AND, OR et MOD seront convertis en un seul caractère approchant la syntaxe du C.<br><br>

			Lorsqu'une directive de lecture ne fait pas référence à un chemin absolu, le répertoire racine au chemin relatif est celui du fichier en cours.<br><br>
		</div>
		<div id="Commandline"><div class="titre1">Ligne de commande</div>
			La syntaxe de base est: rasm.exe &lt;fichier à assembler&gt; [options]<br><br>

			Exemple: <code>rasm.exe monfichier.asm</code>
			<div id="FileOpt"><div class="titre2">Options relatives aux noms de fichiers</div>
			<table class="invisibletable">
				<tr>
					<td>-o &lt;radix de fichier&gt;</td>
					<td>définir un nom commun pour chaque type de fichier en sortie, quel que soit son type (.bin, .cpr, .sym). La valeur par défaut est “rasmoutput”</td>
				</tr>
				<tr>
					<td colspan=2">
						Exemple:<br>
						<code>
							rasm.exe test -o grouik -s<br>
							Pre-processing [test.asm]<br>
							Assembling<br>
							Write binary file <b>grouik</b>.bin (25 bytes)<br>
							Write symbol file <b>grouik</b>.sym (10 bytes)<br>
						</code>
					</td>
				</tr>
				<tr>
					<td>-ob &lt;nom de fichier binaire&gt;</td>
					<td>définir le nom complet pour le fichier de sortie binaire.</td>
				</tr>
				<tr>
					<td>-oc &lt;nom de fichier cartouche&gt;</td>
					<td>définir le nom complet pour le fichier de sortie cartouche.</td>
				</tr>
				<tr>
					<td>-oi &lt;nom de fichier snapshot&gt;</td>
					<td>définir le nom complet pour le fichier de sortie snapshot.</td>
				</tr>
				<tr>
					<td>-os &lt;nom de fichier symbole&gt;</td>
					<td>définir le nom complet pour le fichier de sortie des symboles.</td>
				</tr>
				<tr>
					<td>-ok &lt;nom de fichier breakpoint&gt;</td>
					<td>définir le nom complet pour le fichier de sortie des points d'arrêt.</td>
				</tr>
				<tr>
					<td>-I&lt;répertoire dans lequel chercher les fichiers à inclure&gt;</td>
					<td>définir le répertoire d'inclusion des fichiers, plusieurs options -I cumulables.</td>
				</tr>
				<tr>
					<td>-no</td>
					<td>désactiver toute écriture de fichier</td>
				</tr>
			</table>
			</div>
			<div id="ExportOpt"><div class="titre2">Options d'export sur fichier EDSK</div>
			<table class="invisibletable">
				<tr>
					<td>-eo</td>
					<td> &nbsp; </td> <!-- coz only ony line for the table... -->
					<td>écraser les fichiers sur l'image disque si il y a conflit de nom.</td>
				</tr>
			</table>
			</div>
			<div id="ExportSna"><div class="titre2">Options d'export sur fichier snapshot</div>
			<table class="invisibletable">
				<tr>
					<td>-v2</td>
					<td>Créé un snapshot version 2 (export par défaut en version 3)
				</tr>
				<tr>
					<td>-sb</td>
					<td>Exporte les points d'arrêt (breakpoints) dans le fichier snapshot (compatible avec les formats Winape et ACE), uniquement avec la version 3+</td>
				</tr>
				<tr>
					<td>-ss</td>
					<td>Exporte les symboles dans le fichier snapshot (compatible avec les formats Winape et ACE), uniquement avec la version 3+</td>
				</tr>
			</table>
			</div>
			<div id="SymbOpt"><div class="titre2">Options relatives aux symboles</div>
			<table class="invisibletable">
				<tr>
					<td>-s</td>
					<td>exporter les symboles au format Rasm</td>
				</tr>
				<tr>
					<td colspan=2">
						Exemple de fichier produit:<br>
						<code>
							LABEL1 #0 B0<br>
							LABEL2 #1 B0<br>
							LABEL3 #2 B0<br>
							LABEL4 #4 B0<br>
						</code>
					</td>
				</tr>
				<tr>
					<td>-sp</td>
					<td>exporter les symboles au format Pasmo</td>
				</tr>
				<tr>
					<td colspan=2">
						Exemple de fichier produit:<br>
						<code>
							LABEL1 EQU 00000H<br>
							LABEL2 EQU 00001H<br>
							LABEL3 EQU 00002H<br>
							LABEL4 EQU 00004H<br>
						</code>
					</td>
				</tr>
				<tr>
					<td>-sw</td>
					<td>exporter les symboles au format Winape</td>
				</tr>
				<tr>
					<td colspan=2">
						Exemple de fichier produit:<br>
						<code>
							LABEL1 #0<br>
							LABEL2 #1<br>
							LABEL3 #2<br>
							LABEL4 #4<br>
						</code>
					</td>
				</tr>
				<tr>
					<td>-sl</td>
					<td>option additionnelle aux trois précédentes qui permet d'exporter aussi les symboles locaux aux macros ou boucles de répétition.</td>
				</tr>
				<tr>
					<td>-sv</td>
					<td>option additionnelle aux trois précédentes qui permet d'exporter aussi les variables.</td>
				</tr>
				<tr>
					<td>-sq</td>
					<td>option additionnelle aux trois précédentes qui permet d'exporter aussi les alias <a href="#EQU">EQU</a>.</td>
				</tr>
				<tr>
					<td>-sa</td>
					<td>option équivalente à -sl -sv -sq</td>
				</tr>
				<tr>
					<td>-ss</td>
					<td>exporter les symboles dans un snapshot</td>
				</tr>
				<tr>
					<td>-eb</td>
					<td>exporter les points d'arrêt</td>
				</tr>
				<tr>
					<td>-l &lt;fichier label&gt;</td>
					<td>importer un fichier de labels pour l'assemblage au format Rasm, Sjasm, Pasmo ou Winape. La détection du format est automatique.</td>
				</tr>
				<tr>
					<td>-D&lt;var&gt;=&lt;valeur&gt;</td>
					<td>option pour définir une variable depuis la ligne de commande. Exemple: rasm.exe -DTRUC=1 va définir la variable TRUC à 1.</td>
				</tr>
				<tr>
					<td colspan=2">
						<br><br>
						Note 1: Il est possible de cumuler plusieurs fichiers de symboles en cumulant les options -l<br>
						<code>
							rasm.exe test -l import1.sym -l import2.sym -l import3.sym<br>
						</code>
	Note 2: L'émulateur Arnold est compatible avec Rasm et Pasmo.<br>
	Note 3: L'émulateur Winape n'est pas capable de prendre en charge des labels trop longs!
					</td>
				</tr>
			</table>

			</div>
			<div id="Depend"><div class="titre2">Options de compatibilité</div>
				-depend=make<br>
Exporte toutes les dépendances du programme sur une seule ligne (pour une utilisation en makefile).<br><br>
				-depend=list<br>
Exporte toutes les dépendances du programme, une par ligne.<br><br>
				Si un nom de fichier binaire est spécifié (option -ob) alors il sera ajouté en première position.
			</div>
			<div id="CompOpt"><div class="titre2">Options de compatibilité</div>
			<table class="invisibletable">
				<tr>
					<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td> <!-- html hack for -ass on a single line -->
					<td>&nbsp;</td>
					<td>&nbsp;</td>
				</tr>
				<tr>
					<td>-m</td>
					<td>compatibilité&nbsp;Maxam</td>
					<td><ul>
						<li>calculs réalisés en entiers 16 bits non signés avec un mauvais arrondi</li>
						<li>les comparaisons se font avec l'opérateur = simple</li>
						<li>la priorité des opérateurs est simplifiée (voir tableau)</li>
					</ul></td>
				</tr>
				<tr>
					<td>-ass</td>
					<td>compatibilité&nbsp;AS80</td>
					<td><ul>
						<li>calculs réalisés en entiers 32 bits avec un mauvais arrondi</li>
						<li>les déclarations de type DEFB,DEFW,DEFI ou DEFR multiples ont pour référence d'adresse l'adresse du premier octet produit et non l'adresse de l'octet courant. Cette spécificité d'AS80 fait que deux DEFB ne produisent pas la même chose qu'un seul DEFB avec deux valeurs (quand la référence $ est utilisée).</li>
						<li>les paramètres des macros ne sont plus protégés par les chevrons {}</li>
						<li>la directive MACRO s'utilise après le nom de la macro et non avant</li>
					</ul></td>
				</tr>
				<tr>
					<td>-uz</td>
					<td>compatibilité&nbsp;UZ80</td>
					<td><ul>
						<li>calculs réalisés en entiers 32 bits avec un mauvais arrondi</li>
						<li>les paramètres des macros ne sont plus protégés par les chevrons {}</li>
						<li>la directive MACRO s'utilise après le nom de la macro et non avant</li>
					</ul></td>
				</tr>
			</table>
			</div>
			<div id="DevOpt"><div class="titre2">Options de développement</div>
			<table class="invisibletable">
				<tr>
					<td>-v</td>
					<td>mode verbeux, affiche des informations et statistiques sur l'assemblage</td>
				</tr>
				<tr>
					<td>-d</td>
					<td>produit des informations lors du pré-processing</td>
				</tr>
				<tr>
					<td>-a</td>
					<td>produit des informations lors de l'assemblage</td>
				</tr>
				<tr>
					<td>-n</td>
					<td>affiche les licences tierces</td>
				</tr>
			</table>
			</div>
		</div>
		<div id="Syntax"><div class="titre1">Format du code source</div>
			<div id="GeneraliteFormat"><div class="titre2">Généralité</div>
				L'assembleur n'est pas du COBOL, il est inutile d'indenter vos sources avec Rasm, autrement que pour faire joli. Il n'est pas nécessaire de séparer un label d'une instruction ou d'un autre label par le caractère deux points, bien qu'il soit possible de le faire. La conséquence directe de cette écriture libre implique une différence avec les assembleurs de conception obsolète. Il n'est pas possible (et heureusement) de créer un label qui ait le même nom qu'une directive ou instruction Z80.<br><br>

				Le défaut de cette liberté est que l'assembleur ne peut pas savoir si vous voulez déclarer un label quand vous vous trompez dans l'écriture du nom d'une macro sans paramètre. Pour palier à ce défaut, vous pouvez ajouter un paramètre fictif “(void)” qui déclenchera une erreur si le nom de macro n'est pas connu.<br><br>

				Les fichiers peuvent être lus au format windows ou unix, une conversion interne et transparente sera réalisée en interne.<br><br>

				Rasm n'est pas sensible à la casse, toutes les lettres sont converties en majuscules en interne. Ne soyez pas surpris de ne voir que des majuscules dans les messages d'erreur.<br><br>

				Un label n'est PAS un alias et n'est PAS une variable, Rasm fait la différence!<br><br>

				- un label fait référence à un emplacement mémoire (une adresse et éventuellement une page mémoire si l'espace de travail correspond à une cartouche ou un snapshot)<br>
				- un alias (EQU) est un texte qui, une fois rencontré, est remplacé par un autre, certaines informations étant figées à la définition du texte.<br>
				- une variable est globale à l'ensemble du source, sa valeur doit être initialisée et peut-être modifiée à tout moment.<br>
			</div>
			<div id="CommentaireFormat"><div class="titre2">Commentaires</div>
			La saisie de commentaire sous Rasm est classique et précédée du caractère point-virgule. Tous les caractères suivants sont ignorés jusqu'au prochain retour chariot.<br><br>

			Note: Il n'y a pas de commentaire multi-lignes
			</div>
			<div id="LiteraleFormat"><div class="titre2">Valeurs littérales</div>
				Rasm interprète les valeurs numériques suivantes:<br>
				<ul>
					<li>En décimal si la valeur commence par un chiffre.</li>
					<li>En binaire si la valeur commence par un % ou 0b.</li>
					<li>En octal si la valeur commence par un @.</li>
					<li>En hexadécimal si la valeur commence par un #, un $, 0x ou se termine par un h.</li>
					<li>En valeur ascii si un caractère unique est entre quotes.</li>
					<li>En valeur associée à une variable ou un label, si la littérale commence par une lettre ou un '@' pour les labels locaux.</li>
					<li>Le symbole $ utilisé seul indique l'adresse de début de l'instruction en cours. Lors d'un define type DEFB, DEFW, DEFI, DEFR ou DEFS, l'adresse courante est celle de l'élément en cours. Un DEF* produira les mêmes données que vous utilisiez plusieurs arguments à la suite ou bien plusieurs DEF*.</li>
				</ul>

				Rasm fait tous ses calculs internes en nombre flottant double précision. Un arrondi correct est réalisé en fin de chaine de calcul pour les besoins en nombres entiers.<br><br>

				Attention, le caractère <b>&amp;</b> est réservé pour l'opérateur AND.
			</div>
			<div id="CaractereFormat"><div class="titre2">Caractères autorisés</div>
			Entre quotes, tous les caractères sont autorisés, à vos risques et périls concernant la conversion ASCII vers l'Amstrad. En dehors des quotes, vous pourrez utiliser toutes les lettres, tous les chiffres, le point, l'arobas, les parenthèses, le dollar, les opérateurs plus, moins, multiplié, divisé, le pipe, circonflexe, le pourcent, le dièse, le paragraphe, les chevrons et les deux types de quotes.<br><br>
			Les chaines de caractères entre quotes peuvent contenir des caractères échappés:<br>
			<li>\t</li><br>
			<li>\n</li><br>
			<li>\r</li><br>
			<li>\f</li><br>
			<li>\v</li><br>
			<li>\b</li><br>
			<li>\0</li> -&gt; sauf avec le PRINT<br>
			</div>
			<div id="FichierFormat"><div class="titre2">Fichiers</div>
				RASM utilise en interne le modèle de fichiers UNIX qu'il converti automatiquement au besoin. En utilisant uniquement des chemins relatifs (et des noms de fichiers que Windows peut comprendre), on peut tout à fait avoir un code qui compile à la fois sous UNIX et Windows sans faire de modification.<br><br>

				La règle de gestion des chemins relatifs est simple. Tout chemin relatif a pour origine le répertoire du fichier dans lequel il a été lu.
			</div>
			<div id="LabelFormat"><div class="titre2">Labels</div>
				À l'intérieur d'une boucle (REPEAT/WHILE/UNTIL) ou dans une macro, il est possible d'utiliser des labels locaux de la même façon qu'avec l'assembleur intégré de Winape en préfixant le label par le caractère '@'.<br><br>

				À chaque itération de boucle et ce, pour chaque imbrication de boucle, un suffixe est ajouté au label local contenant la valeur hexadécimale du compteur interne de répétition. Il est ainsi possible d'appeler un label local à une répétition en dehors de la boucle, mais cet usage n'est pas conseillé.<br><br>

				Il est possible d'utiliser la valeur d'un label dans une commande (ORG par exemple) si et seulement si le label précède la directive.<br><br>

				Tout label qui commence par le préfixe BRK ou @BRK génère aussi un <a href="#BREAKPOINT">point d'arrêt</a>.<br><br>

				En mode DAMS, il est possible d'utiliser la déclaration désuète d'un label en le préfixant d'un point. L'appel à ce label se fera sans le point du début. L'usage des labels de proximité est alors désactivé.<br><br>
			</div>
			<div id="LocalLabelFormat"><div class="titre2">Labels locaux non exportables</div>
				On peut déclarer un label local à l'intérieur d'une macro ou d'une boucle. Ce label sera invisible hors de son contexte (hors de la macro, ou à chaque répétition de boucle).<br><br>

				Les labels locaux sont préfixés par le caractère '@'.<br><br>

				Exemple d'utilisation d'un label local dans une boucle:<br>
				<code>
					repeat 16<br>
					add hl,bc<br>
					jr nc,@no_overflow<br>
					dec hl<br>
					@no_overflow<br>
					rend<br>
				</code>
			</div>
			<div id="ExpLocalLabelFormat"><div class="titre2">Labels de proximité</div>
				Hors d'une macro ou d'une boucle, les labels locaux héritent du label global qui précède.<br><br>

				Exemple d'utilisation d'un label de proximité:<br>
				<code>
					routine1<br>
					add hl,bc<br>
					jr nc,.no_overflow<br>
					dec hl<br>
					.no_overflow<br>
					<br>
					routine2<br>
					add hl,bc<br>
					jr nc,.no_overflow<br>
					dec hl<br>
					.no_overflow<br>
					<br>
					routine3<br>
					xor a<br>
					ld hl,routine1.no_overflow ; récupération du label local à routine1<br>
					ld de,routine2.no_overflow ; idem routine2<br>
					sbc hl,de<br>
				</code>
			</div>
			<div id="LabelTagFormat"><div class="titre2">Tags spécifiques aux labels ou structures</div>
				<div id="TagBANK" class="titre3">{BANK}</div>
				Le préfixe {BANK} devant un label (exemple: {BANK}monlabel ) permet de récupérer la valeur de la <a href="#BANK">BANK</a> dans laquelle est déclaré le label, plutôt que l'adresse du label.<br><br>

				Exemple d'utilisation du tag:<br>
				<code>
					bank 0<br>
					ld a,{bank}maroutine ; sera assemblé LD A,1<br>
					call connect_bank<br>
					jp maroutine<br>
					bank 1<br>
					defb 'coucou'<br>
					maroutine<br>
					jr $<br>
				</code>

				<div id="TagPAGE" class="titre3">{PAGE}</div>
				Le préfixe {PAGE} devant un label (exemple: {PAGE}monlabel ) permet de récupérer la valeur type Gate array de la <a href="#BANK">BANK</a> dans laquelle est déclaré le label, plutôt que l'adresse du label. Par exemple pour un label situé dans la <a href="#BANK">BANK</a> 5 la valeur retournée sera #C5<br><br>
				Si vous utilisez l'adressage mémoire par 64K avec la directive <a href="#BANKSET">BANKSET</a>, alors la valeur gate array sera déduite du set de 64K ainsi que de l'adresse du label (2 bits de poids fort)<br><br>

				Exemple d'utilisation du tag:<br>
				<code>
					buildsna ; force mode snapshot<br>
					Bank 0<br>
					ld a,{page}maroutine ; sera assemblé LD A,#C5<br>
					ld b,#7F<br>
					out (c),a<br>
					jp maroutine<br>
					bank 5<br>
					defb 'coucou'<br>
					maroutine<br>
					jr $<br>
				</code>
				<div id="TagPAGESET" class="titre3">{PAGESET}</div>
				Le préfixe {PAGESET} devant un label (exemple: {PAGESET}monlabel ) permet de récupérer la valeur type Gate array du BANKSET dans lequel est déclaré le label, plutôt que l'adresse du label. Par exemple pour un label situé dans la <a href="#BANK">BANK</a> 5 la valeur retournée sera #C2<br><br>

				Exemple d'utilisation du tag:<br>
				<code>
					bank 0<br>
					ld a,{pageset}maroutine ; sera assemblé LD A,#C2<br>
					ld b,#7F<br>
					out (c),a ; vu qu'on commute toute la RAM le code est supposé être exécuté depuis la ROM dans la majorité des cas<br>
					jp maroutine<br>
					bank 5<br>
					defb 'coucou'<br>
					maroutine<br>
					jr $<br>
				</code>
				<div id="TagSIZEOF" class="titre3">{SIZEOF}</div>
				Le préfixe {SIZEOF} devant un nom de <a href="#Structures">structure</a> ou de sous-structure permet de récupérer la taille de cette dernière.<br><br>

				Voir la définition des structures <a href="#STRUCT">ici</a>.
			</div>
			<div id="Coloration"><div class="titre2">Coloration syntaxique dans VIM</div>
				<ul>
					<li>Si vous avez déjà le fichier de coloration syntaxique Z80 il suffit d'ajouter les lignes suivantes au fichier <code>.vim/syntax/z80.vim</code><br></li>
					<li>Ou vous pouvez télécharger le fichier complet de syntaxe <a href="z80.vim">ici</a></li>
				</ul>
				<br>
				<code>
					&quot; rasm/winape directives<br>
					syn keyword z80PreProc charset bank write save include incbin incl48 incl49<br>
					syn keyword z80PreProc macro mend switch case break while wend repeat until<br>
					syn keyword z80PreProc buildcpr amsdos lz48 lz49 lzclose protect<br>
					syn keyword z80PreProc direct brk let print stop nolist str<br>
					syn keyword z80PreProc defr dr defi bankset page pageset sizeof endm struct endstruct ends<br>
					syn keyword z80PreProc incexo lzexo lzx7 inczx7 buildsna setcrtc setcpc assert print<br>
					syn keyword z80Reg lix liy hix hiy<br>
				</code>

			</div>
		</div>
		<div id="Expressions"><div class="titre1">Expressions</div>
			<div id="Operateurs"><div class="titre2">Opérateurs de calcul</div>
			Rasm utilise un moteur d'expression simplifié à priorités multiples (comme le C). Il supporte les opérateurs et fonctions suivant(e)s:<br>
			<ul>
				<li>* multiplication</li>
				<li>/ division</li>
				<li>+ addition</li>
				<li>- soustraction</li>
				<li>&amp; ou AND opérateur logique ET</li>
				<li>| ou OR opérateur logique OU</li>
				<li>^ ou XOR opérateur logique OU exclusif</li>
				<li>% ou MOD pour faire le modulo</li>
				<li>&amp;&amp; opérateur booléen ET</li>
				<li>|| opérateur booléen OU</li>
				<li>&lt;&lt;  multiplication par la puissance n de deux</li>
				<li>&gt;&gt; division par la puissance n de deux</li>
				<li>hi() poids fort de l'entier 16 bits</li>
				<li>lo() poids faible de l'entier 16 bits</li>
				<li>sin() calcul de sinus</li>
				<li>cos() calcul de cosinus</li>
				<li>asin() calcul d'arc-sinus</li>
				<li>acos() calcul d'arc-cosinus</li>
				<li>atan() calcul d'arc-tangente</li>
				<li>int() conversion en nombre entier</li>
				<li>floor() conversion au nombre entier directement inférieur</li>
				<li>abs() valeur absolue</li>
				<li>ln() logarithme népérien</li>
				<li>log10() logarithme base 10</li>
				<li>exp() exponentielle</li>
				<li>sqrt() racine carrée</li>
				<li>== égalité (ou un seul = en mode Maxam)</li>
				<li>!= ou &lt;&gt; différent de</li>
				<li>&lt;= inférieur ou égal</li>
				<li>&gt;= supérieur ou égal</li>
				<li>&lt; inférieur</li>
				<li>&gt; supérieur</li>
			</ul>
			</div>
			<div id="Priorites"><div class="titre2">Priorité d’exécution des opérateurs</div>
			<table border="1" class="visibletable">
				<tr>
					<th colspan="3">Plus la prévalence est faible, plus l'opération est prioritaire.</th>
				</tr>
				<tr>
					<td>Opérateurs</td>
					<td>Prévalence Rasm</td>
					<td>Prévalence Maxam</td>
				</tr>
				<tr>
					<td>( &nbsp; )</td>
					<td>0</td>
					<td>0</td>
				</tr>
				<tr>
					<td>! &nbsp;</td>
					<td>1</td>
					<td>464</td>
				</tr>
				<tr>
					<td>* &nbsp; / &nbsp; %</td>
					<td>2</td>
					<td>464</td>
				</tr>
				<tr>
					<td>+ &nbsp; -</td>
					<td>3</td>
					<td>464</td>
				</tr>
				<tr>
					<td>&lt;&lt; &nbsp; &gt;&gt;</td>
					<td>4</td>
					<td>464</td>
				</tr>
				<tr>
					<td>&lt; &nbsp; &lt;= &nbsp; == &nbsp; =&gt; &nbsp; &gt; &nbsp; !=</td>
					<td>5</td>
					<td>664</td>
				</tr>
				<tr>
					<td>&amp; &nbsp; AND</td>
					<td>6</td>
					<td>464</td>
				</tr>
				<tr>
					<td>| &nbsp; OR</td>
					<td>7</td>
					<td>464</td>
				</tr>
				<tr>
					<td>^ &nbsp; XOR</td>
					<td>8</td>
					<td>464</td>
				</tr>
				<tr>
					<td>&amp;&amp;</td>
					<td>9</td>
					<td>6128</td>
				</tr>
				<tr>
					<td>||</td>
					<td>10</td>
					<td>6128</td>
				</tr>
			</table>
			</div>
		</div>

		<div id="Variables"><div class="titre1">Variables</div>
			<div id="Statiques"><div class="titre2">Variables statiques ou alias</div>
			Il est possible de créer un nombre illimité d’alias avec la directive <a href="#EQU">EQU</a>. Ces alias ne peuvent pas être modifiés une fois qu'ils sont définis.
			</div>
			<div id="Dynamiques"><div class="titre2">Variables dynamiques</div>
			Rasm autorise un nombre illimité de variables pour des calculs internes.<br><br>

			Syntaxe:<br>
			<code>
			mavariable=5<br>
			LET mavariable=5 ; syntaxe compatible Winape
			</code>

			Ces variables peuvent être utilisées comme offset lors d'une boucle de répétition ou comme opérateurs de calcul pour créer des tables de données.<br><br>

			Exemples:<br>
			<code>
			dep=0<br>
			repeat 16<br>
			ld (ix+dep),a<br>
			dep=dep+8<br>
			rend<br>

			ang=0<br>
			repeat 256<br>
			defb 127*sin(ang)<br>
			ang=ang+360/256<br>
			rend<br>
			</code>
			</div>
		</div>
		<!-- ****************************************** -->
		<!--        D I R E C T I V E S                 -->
		<!-- ****************************************** -->
			Une directive n'est pas une fonction, c'est un mot clef qui doit être séparé de ses paramètres par au moins un espace.<br><br>
			
			Syntaxe correcte: ASSERT (4*mavar)<br>
			Syntaxe incorrecte: ASSERT(4*mavar)<br>
			
		<div id="DirectivesM"><div class="titre1">Directives mémoires</div>
			<div id="ALIGN"><div class="titre2">ALIGN &lt;valeur d'alignement&gt;[,valeur de remplissage]</div>
				Si l'adresse d'écriture du code en cours n'est pas un multiple de la valeur d'alignement, on augmente cette dernière afin que ça soit le cas. Utilisée avec un seul paramètre, cette instruction ne produit pas d'octet sur la sortie. Ainsi, par défaut ce sont des zéros qui seront en mémoire si on réalise un ALIGN entre deux portions de code.<br><br>
				Utilisée avec le paramètre de remplissage, des octets seront produits (même si la valeur est zéro) et ces données seront comptées dans le calcul d'enregistrement automatique de binaire ainsi que dans le contrôle d'écrasement mémoire.<br><br>
				Exemple:<br>
				<code>
					ALIGN 2 ; aligner le code sur une adresse paire<br>
					ALIGN 256 ; aligner le code sur le poids fort de l'adresse<br>
				</code>
			</div>
			<div id="BANK"><div class="titre2">BANK [numéro de page ROM, numéro de page RAM]</div>
				Sélectionner un emplacement ROM (cartouche) ou RAM (snapshot). L'usage de cette instruction active par défaut l'écriture de la cartouche en fin d'assemblage.<br><br>

				Les valeurs possibles vont de 0 à 31. En mode snapshot on peut aussi utiliser cette directive, cette fois avec des valeurs de 0 à 35 (64K de base + 512K d'extension mémoire).<br><br>

				Sans paramètre, la directive ouvre un nouvel espace mémoire de travail
			</div>
			<div id="BANKSET"><div class="titre2">BANKSET &lt;numéro de bloc de 64K&gt;</div>
				Sélectionner un emplacement mémoire pour les snapshots, en groupant les pages 4 à 4. Le format snapshot v3 supportant au maximum une extension de 512K, il y a 9 sets mémoire indexés de 0 à 8.<br><br>

				Il est possible d'utiliser BANK et BANKSET en même temps mais il est impératif de ne pas sélectionner la même page à la fois avec BANK et BANKSET. Un contrôle déclenchera une erreur si vous tentez de le faire.<br><br>

				L'appel de cette directive force automatiquement la génération de snapshot.
			</div>
			<div id="LIMIT"><div class="titre2">LIMIT &lt;adresse limite&gt;</div>
				Imposer une limite plus basse à l'écriture de l'assemblage. Par défaut, la limite est de 65536 mais on peut avoir besoin de ne pas dépasser une certaine valeur.<br><br>

				Pour protéger une zone définie, il vaut mieux utiliser la fonction <a href="#PROTECT">PROTECT</a>.
			</div>
			<div id="ORG"><div class="titre2">ORG &lt;adresse logique&gt;[,adresse d'écriture du code]</div>
				Assembler le code à une adresse spécifique. On peut optionnellement choisir d'assembler le code à une adresse, mais l'écrire à un autre endroit avec le deuxième paramètre.<br><br>
				
				Assembler le code à une adresse absolue:<br>
				<code>
				ORG #8000<br>
				defw $<br>
				; bytecode produit<br>
				#8000: #00,#80<br>
				</code>

				<br>
				Assembler le code à une adresse autre que celle du code:<br>
				<code>
				ORG #8000,#1000<br>
				defw $<br>
				; bytecode produit<br>
				#1000: #00,#80<br>
				</code>

				<br>
				Retrouver l'adresse physique après l'avoir modifiée:<br>
				<code>
				ORG #8000,#1000<br>
				defw $      ; cette instruction est logiquement en #8000 mais physiquement écrite en #1000<br>
				ORG $       ; le ORG s'affranchit de l'adresse logique, on est physiquement en #1002 après le defw<br>
				defw $      ; adresse courante est #1002<br>
				; bytecode produit<br>
				#1000: #00,#80,#02,#10<br>
				</code>
				
			</div>
			<div id="PROTECT"><div class="titre2">PROTECT &lt;adresse de début&gt;,&lt;adresse de fin&gt;</div>
				Empêcher l'écriture de données dans la zone début/fin de l'espace mémoire courant.
			</div>
			<div id="WRITE"><div class="titre2">WRITE DIRECT &lt;rom basse&gt;[,&lt;rom haute&gt;[,&lt;RAM&gt;]]</div>
				Cette directive est présente pour compatibilité avec Winape, son usage est déconseillé. Utilisez de préférence les directives <a href="#BANK">BANK</a> ou <a href="#BANKSET">BANKSET</a>.<br><br>

				En spécifiant une rom basse (entre 0 et 7) ou une rom haute (entre 0 et 31), cette directive a le même effet que la directive <a href="#BANK">BANK</a>.<br><br>

				En spécifiant uniquement l'adresse RAM (n'importe quelle valeur) et en désactivant les numéros de rom avec la valeur -1, on créé à chaque appel un nouvel espace mémoire. On peut ainsi assembler plusieurs code au même emplacement mémoire, mais dans un espace différent. Cet usage est équivalent à la directive <a href="#BANK">BANK</a> sans paramètre.
			</div>
		</div>
		
		<div id="DirectivesD"><div class="titre1">Directives de définition de données</div>
			<div id="CHARSET"><div class="titre2">CHARSET 'chaine',&lt;valeur&gt; | &lt;code&gt;,&lt;valeur&gt; | &lt;début&gt;,&lt;fin&gt;,&lt;valeur&gt;</div>
				La directive permet de redéfinir des valeurs aux caractères assemblés entre quotes selon quatre formats:<br>
				<ul>
					<li>'chaine',&lt;valeur&gt; &rarr; Le premier caractère de la chaine aura pour nouvelle valeur la &lt;valeur&gt;. Le caractère suivant &lt;valeur&gt;+1 et ainsi de suite pour tous les caractères de la chaine.</li>
					<li>&lt;code&gt;,&lt;valeur&gt; &rarr; Attribuer au caractère de valeur ASCII &lt;code&gt; la valeur &lt;valeur&gt;.</li>
					<li>&lt;début&gt;,&lt;fin&gt;,&lt;valeur&gt; &rarr; Attribuer aux caractères de valeur ASCII &lt;début&gt; à &lt;fin&gt; une valeur incrémentale en partant de &lt;valeur&gt;.</li>
					<li>aucun paramètre &rarr; réassigne à tous les caractères leur valeur ASCII par défaut.</li>
				</ul>
				Cette fonction est compatible Winape.<br><br>
				
				<br>
				Redéfinir un caractère:<br>
				<code>
				CHARSET 'T','t' ; les T majuscules seront écrits t minuscules<br>
				defb 'tT'<br>
				; bytecode produit<br>
				#0000: #74 #74<br>
				</code>
				
				<br>
				Redéfinir quelques caractères non consécutifs:<br>
				<code>
				CHARSET 'turndiskheo ',0<br>
				defb 'there is no turndisk'<br>
				; bytecode produit<br>
				#0000: #00,#08,#09,#02,#0B,#05,#06,#0B,#03,#0A,#0B,#00,#01,#02,#03,#04,#05,#06,#07<br>
				</code>

				<br>
				Redéfinir des caractères consécutifs:<br>
				<code>
				CHARSET 'A','Z','a' ; transformer toutes les majuscules en minuscules<br>
				defb 'abcdeABCDE'<br>
				; bytecode produit<br>
				#0000: #61,#62,#63,#64,#65,#61,#62,#63,#64,#65<br>
				</code>
			</div>
			<div id="DEFB"><div class="titre2">DB, DEFB, DM, DEFM &lt;valeur&gt;[,&lt;valeur&gt;,...]</div>
			Cette directive prend un ou plusieurs paramètres et génère une suite d'octets représentative des paramètres en entrée. La valeur peut être une valeur litérale, une formule dont le résultat sera éventuellement arrondi et tronqué ou même une chaine de caractères dont chaque caractère produira un octet en sortie égale à sa valeur ASCII, sauf si la directive CHARSET a été utilisée pour redéfinir ces valeurs.<br><br>

			Exemple:<br>
			<code>
			defb 'r'-'a'+'A',oudoudou',#FF,lo($)<br>
			</code>
			La référence d'adresse courante est celle de l'octet en cours par défaut.
			</div>
			<div id="DEFW"><div class="titre2">DEFW, DW &lt;valeur&gt;[,&lt;valeur&gt;,...]</div>
			Cette directive prend un ou plusieurs paramètres et génère une suite de mots (deux octets) représentative des paramètres en entrée. Les valeurs peuvent être une valeur littérale, une formule dont le résultat sera éventuellement arrondi et tronqué. Cette directive ne supporte pas une chaine de plusieurs caractères comme valeur.<br><br>

			Exemple:<br>
			<code>
			defw mylabel1,mylabel2,'a'+#100<br><br>
			</code>
			</div>

			<div id="DEFI"><div class="titre2">DEFI</div>
				Cette direction prend un ou plusieurs paramètres et génère une suite de double-mots (4 octets) représentative des paramètres en entrée. Les valeurs peuvent être une valeur littérale, une formule dont le résultat sera éventuellement arrondi et tronqué. Cette directive ne supporte pas une chaine de plusieurs caractères comme valeur.<br>
			</div>
			<div id="DEFR"><div class="titre2">DEFR, DR &lt;nombre réel&gt;[,&lt;nombre réel&gt;,...]</div>
				Cette directive prend un ou plusieurs paramètres et génère une suite de nombre réels (5 octets chaque) compatibles avec le firmware des Amstrad CPC.<br><br>
				Exemple:<br>
				<code>
					defr 5/12,7/3<br>
				</code>
			</div>
			<div id="DEFS"><div class="titre2">DEFS, DS &lt;répétition&gt;[,&lt;valeur&gt;,[&lt;répétition&gt;,...]</div>
				Cette directive génère une suite d'octets répétitive. Si la valeur de remplissage est omise alors zéro sera pris par défaut. Si la valeur de répétition est nulle alors aucun octet ne sera produit. Il est possible de déclarer plusieurs suites de répétition avec le même DEFS mais les premières répétitions sera toujours interprétées comme ayant une valeur à répéter.<br><br>

				Exemple:<br>
				<code>
					defs 5,8,4,1 ; output=#08,#08,#08,#08,#08,#01,#01,#01,#01<br>
					defs 5,8,4   ; output=#08,#08,#08,#08,#08,#00,#00,#00,#00<br>
					defs 5       ; output=#00,#00,#00,#00,#00<br>
				</code>
			</div>
			<div id="EQU"><div class="titre2">&lt;alias&gt; EQU &lt;chaine de remplacement&gt;</div>
				Création d'un alias. Quand l'assembleur rencontrera l'alias dans une expression, le texte sera remplacé par celui défini lors du EQU. Un test de récursivité infini est réalisé à la création de l'alias.<br><br>
				Exemple:<br>
				<code>
					tab1 EQU #8000<br>
					tab2 EQU tab1+#100<br>
					<br>
					ld hl,tab2<br>
				</code>
			</div>
			<div id="STR"><div class="titre2">STR 'chaine1'[,'chaine2'...]</div>
				Directive similaire à <a href="#DEFB">DEFB</a>, sauf que le dernier caractère de chaque chaine aura son bit 7 forcé à 1 (opération OR #80 sur le dernier octet).<br><br>

				Les deux lignes suivantes produiront les mêmes octets:<br>
				<code>
					defb 'roudoudo','u'+128<br>
					str 'roudoudou'<br>
				</code>
			</div>
			<div id="STRUCT"><div class="titre2">STRUCT &lt;nom de prototype&gt;[,&lt;nom de variable&gt;]</div>
				Le Z80 est particulièrement apte à traiter des structures de données grâce aux instructions indexées (registres IX et IY) mais on peut simplement vouloir déclarer des structures par convenance personnelle.<br><br>

				Exemple de création d’une structure<br>
				<code>
					struct st1<br>
					ch1 defw 0<br>
					ch2 defb 0<br>
					endstruct<br>
					La structure st1 est créée avec deux champs ch1 et ch2. Aucun octet n’est produit en mémoire.<br>
					Imbriquer les structures<br>
					struct metast1<br>
					struct st1 pr1<br>
					struct st1 pr2<br>
					endstruct<br>
					La structure metast1 est créée avec deux sous-structures de type st1 appellées pr1 et pr2<br>
				</code>
				<br>
				Pour récupérer la taille d’une structure, il est recommandé d’utiliser le préfixe {SIZEOF}. La taille d’une structure peut être récupérée avec le nom de son prototype comme Vasm mais cette pratique est fortement déconseillée et n’existe qu’à des fins de compatibilité.<br>
				<code>
					LD HL,{SIZEOF}metast1<br>
					LD HL,metast1<br>
				</code>
				<br>
				La directive STRUCT appelée avec deux paramètres va créer en mémoire une structure sur la base d’un prototype existant, qu’il faudra nommer. Par exemple ci-dessous, on va créer une structure mymeta de type metast1.<br><br>
				<code>
					struct metast1 mymeta<br>
				</code>
				<br>
				On peut récupérer les offsets des champs d’une structure en utilisant les informations du prototype:<br>
				<code>
					LD A,(IX+metast1.pr2.ch1) ; offset car prototype utilisé<br>
				</code>
				<br>
				Si on utilise le nom d’une structure statique alors c’est l’adresse absolue qui est renvoyée:<br>
				<code>
					LD HL,mymeta.pr2.ch1<br>
					LD A,(HL)<br>
				</code>
			</div>
		</div>
		<div id="DirectivesI"><div class="titre1">Directives d'import et de compression</div>
			<div id="INCLUDE"><div class="titre2">INCLUDE, READ 'fichier à lire'</div>
				Lire un fichier texte et l'intégrer au code source à l'emplacement de l'instruction de lecture. Le chemin relatif de lecture a pour racine l'emplacement du fichier dans lequel est l'instruction de lecture. Un chemin absolu s'affranchit de ce répertoire racine.<br><br>

				Il n'y a pas de limite de récursivité en lecture. Attention à ce que vous faites.
			</div>
			<div id="INCBIN"><div class="titre2">INCBIN 'fichier à lire'[,offset[,size[,offset étendu[,OFF]]]] ou INCBIN 'fichier wav',SMP|SM2|SM4|DMA</div>
				Lire un fichier binaire. Les données lues seront directement injectées. Les paramètres optionnels sont compatibles avec la fonction INCBIN de Winape. L'offset n'est pas limité à 64Ko comme Winape. L'offset étendu est là pour compatibilité. Son usage est à éviter pour rester lisible.<br><br>

				Il est possible de donner un offset négatif, relatif à la fin du fichier.<br><br>

				Il est possible de donner une taille de fichier négative. La taille lue sera égale à la taille totale du fichier ajoutée à cette valeur négative. Pour tout lire sauf les 10 derniers octets, on précisera une taille de -10 dans la commande.<br><br>

				Une taille de zéro chargera tout le fichier.<br><br>

				Paramètre OFF: Si on souhaite charger un fichier pour initialiser de la “mémoire” et qu'on souhaite assembler du code par dessus, on peut désactiver pour la lecture de ce fichier le contrôle d'écrasement.<br><br>

				Exemple:<br>
				<code>
					org #4000<br>
					incbin'makeraw.bin',0,0,0,OFF ; lecture en #4000 avec contrôle d'écrasement désactivé<br>
					org #4001<br>
					defb #BB ; écrasement du deuxième octet sans erreur<br>
				</code>
				Exemple de lecture de fichier audio:<br>
				<code>
					org #4000<br>
					incbin'sound.wav',DMA<br>
				</code>
				Les fichiers WAV sont à priori tous supportés quel que soit leur format, mono-canal ou multi-canal. Une fusion des voix sera réalisée en cas de fichier multi-canal. La fréquence d'échantillonage n'est pas prise en compte. Chaque échantillon sera converti en une valeur PSG. Vos fichiers audio pour liste DMA devront au préalable avoir été converti à 15600Hz. Pour les samples classiques, à votre vitesse de relecture. Il existe deux formats additionnels pour les samples classiques nommés SM2 et SM4.<br><br>
				Le format SM2 contient deux valeurs sur un seul octet, premier échantillon dans les bits de poids fort.<br><br>
				Le format SM4 contient quatre valeurs sur un seul octet, premier échantillon dans les bits de poids fort. Le système retenu est le suivant. Les valeurs codées sont les valeurs 0,13,14,15. Ainsi on peut coder sur seulement 2 bits avec toute l'amplitude 4 bits du PSG. Il suffit de copier les deux bits en position 2 et 3. Le zéro reste zéro de facto.<br><br>
			</div>
			<div id="INCL48"><div class="titre2">INCL48, INCL49, INCLZ4, INCZX7, INCEXO 'fichier à lire'</div>
				Lire un fichier binaire, le compresser en LZ48, LZ49, LZ4, Exomizer ou ZX7 et l'injecter directement dans le code.
			</div>
			<div id="LZ"><div class="titre2">LZ48, LZ49, LZ4, LZX7, LZEXO</div>
				Ouvrir un segment de code compressé en LZ48,LZ49, LZ4, ZX7 ou Exomizer. Le code produit sera compressé après assemblage et l'ensemble du code situé après la zone sera relogé.<br><br>

				Il n'est pas possible d'appeler un label situé après un segment compressé depuis le code compressé pour des raisons évidentes dûes aux aléas de la compression. Une erreur s'affichera expliquant pourquoi.<br><br>

				Limitations:<br>
				<ul>
					<li>Le code ou les données d'une zone LZ ne peut excéder l'espace d'adressage de 64Ko.</li>
					<li>Il n'est pas possible d'imbriquer les segments compressés.</li>
				</ul>
				<br>
				Exemple:<br>
				<code>
					org #1000<br>
					ld hl,zecrunch<br>
					ld de,#8000<br>
					call decrunch<br>
					call #8000<br>
					jp next ; label next after crunched zone will be relocated<br>
					<br>
					zecrunch<br>
					lz48 ; this section will be crunched<br>
					org #8000,$<br>
					nop<br>
					nop<br>
					nop<br>
					ret<br>
					lzclose<br>
					<br>
					next<br>
					ret<br>
				</code>

			</div>
			<div id="LZCLOSE"><div class="titre2">LZCLOSE</div>
				Fermer une zone LZ.
			</div>
		</div>

		<div id="DirectivesC"><div class="titre1">Directives de code conditionnel</div>
			<div id="ASSERT"><div class="titre2">ASSERT &lt;condition&gt;[,texte,texte,texte,...]</div>
				Vérifier une condition et arrêter l'assemblage si la condition est fausse.<br><br>
				Exemple:<br>
				<code>
					assert mygenend-mygenstart&lt;#100<br>
					assert mygenend-mygenstart&lt;#100,'code trop gros'<br>
				</code>
			</div>
			<div id="IFTHEN"><div class="titre2">IF &lt;condition&gt;, IFNOT &lt;condition&gt;, ELSE, ELSEIF &lt;condition&gt;, ENDIF</div>
				Directive de test et définition de blocs pour le code conditionnel.<br><br>

				Exemple:<br>
				<code>
					CODE_PRODUCTION=1<br>
					[...]<br>
					if CODE_PRODUCTION<br>
					or #80<br>
					else<br>
					print 'version de test'<br>
					endif<br>
				</code>

			</div>
			<div id="IFDEF"><div class="titre2">IFDEF, IFNDEF &lt;variable ou label&gt;</div>
				Ces deux directives permettent de tester l'existence ou la non existence d'une variable ou d'un label, AVANT la directive.
			</div>
			<div id="IFUSED"><div class="titre2">IFUSED, IFNUSED &lt;variable ou label&gt;</div>
				Ces deux directives permettent de tester l'utilisation ou la non utilisation d'une variable ou d'un label, AVANT la directive.
			</div>
			<div id="MACRO"><div class="titre2">MACRO</div>
				Rasm supporte les macros avec chevrons (compatible avec Winape). Il est possible de faire de l'assemblage conditionnel avec les macros car à chaque appel de macro, le code d'origine est inséré, les paramètres substitués et enfin le code est interprété de façon classique.<br><br>

				Exemple pour une écriture longue distance générique (sauf pour B ou C):<br>
				<code>
					macro LDIXREG registre,dep ; chaque paramètre séparé par une virgule<br>
					if {dep}<-128 || {dep}>127<br>
					push bc<br>
					ld bc,{dep}<br>
					add ix,bc<br>
					ld (ix+0),{registre}<br>
					pop bc<br>
					else<br>
					ld (ix+{dep}),{registre}<br>
					endif<br>
					mend<br>
				</code>

				Note: Le marqueur de fin de macro peut être indifférement MEND ou ENDM<br><br><br>


				<i>Macros sans paramètre</i><br>
				En cas de faute de frappe, pour éviter que la macro mal orthographiée soit remplacée par un label, il est conseillé d'utiliser le paramètre (VOID) à chaque appel. Ainsi, si la macro est mal orthographiée, la présence du (VOID) déclenchera une erreur.<br><br>
				<code>
					macro sansparam<br>
					nop<br>
					mend<br>
					<br>
					sansparam (void) ; appel sécurisé de la macro<br>
				</code>

				<br><br><i>Appel de macro en paramètre statique ou dynamique</i><br>
				Les macros de Rasm sont (en logique interne) du code qui est remplacé au vol lors de l'assemblage. Il y a deux possibilités de remplacement pour les paramètres. Soit le paramètre est copié tel que, soit il peut être calculé et c'est sa valeur calculée qui sera injecté dans la macro.<br><br>
				<code>
					macro test myarg<br>
					defb {myarg}<br>
					mend<br>
					<br>
					repeat 2<br>
					test repeat_counter<br>
					rend<br>
					repeat 2<br>
					test {eval}repeat_counter<br>
					rend<br>
				</code>

				Dans la première boucle, c'est la ligne defb repeat_counter qui sera développée tandis que le second appel, avec le paramètre précédé du tag {eval}, c'est la première valeur de repeat_counter qui sera développée, entrainant deux defb identiques.
			</div>
			<div id="PRINT"><div class="titre2">PRINT 'chaine',&lt;variable&gt;,&lt;expression&gt;</div>
				Écrire du texte, variables ou expressions lors de l'assemblage. Concernant les valeurs numériques l'affichage par défaut est un nombre flottant mais il est possible de formater les variables en préfixant la variable par des tags:<br><br>
				<div class="titre3">{hex}</div>afficher la variable en hexadécimal. Si la variable vaut moins de #FF alors l'affichage sera forcé sur deux chiffres. Si la variable vaut moins de #FFFF alors l'affichage sera forcé sur quatre chiffres. Au dessus il n'y aura pas d'extra-zéros.

				<div class="titre3">{hex2}, {hex4}, {hex8}</div>pour forcer l'affichage quel que soit la valeur, sur 2, 4 ou 8 chiffres.

				<div class="titre3">{bin}</div>afficher la variable en binaire. Si la variabke vaut moins de #FF alors l'affichage sera forcé sur 8 bits. Si la variable vaut moins de #FFFF alors l'affichage sera forcé sur 16 bits. Un pré-traitement enlève les 16 bits supérieurs de la valeur 32 bits au cas où tous les bits sont à 1 (nombre négatif).

				<div class="titre3">{bin8},{bin16},{bin32}</div>pour forcer l'affichage quel que soit la valeur, sur 8, 16 ou 32 bits.

				<div class="titre3">{int}</div>afficher en décimal, nombre entier.

			</div>
			<div id="FAIL"><div class="titre2">FAIL 'chaine',&lt;variable&gt;,&lt;expression&gt;</div>
				Directive dérivée de PRINT, qui sort de Rasm en erreur.
			</div>
			<div id="REPEAT"><div class="titre2">REPEAT &lt;nombre de répétition&gt;[,variable], REND / REPEAT, UNTIL &lt;condition&gt;</div>
				Répète un bloc d'instructions. On peut soit fixer un nombre de répétitions, soit utiliser le mode conditionnel avec la directive de fin de bloc UNTIL. Il est possible à tout moment de consulter le numéro d'itération du repeat courant avec la variable REPEAT_COUNTER. Pour le cas de répétition non conditionnel, on peut donner un nom de variable (qui existe déjà ou non) pour que le compteur y soit recopié à chaque itération.<br><br>

				Exemple:<br>
				<code>
					repeat 10<br>
					ldi<br>
					print repeat_counter<br>
					rend<br>
					<br>
					cpt=10<br>
					repeat<br>
					ldi<br>
					cpt=cpt-1<br>
					until cpt&gt;0<br>
				</code>

				Exemple avec compteur exporté:<br>
				<code>
					repeat 10,hello<br>
					ldi<br>
					print hello<br>
					rend<br>
					<br>
				</code>
				Note: La variable 'hello' peut exister ou non. Si elle n'existe pas au début du REPEAT, elle sera crée.
			</div>
			<div id="STOP"><div class="titre2">STOP</div>
				Arrêter l'assemblage. Aucun fichier ne sera écrit.
			</div>
			<div id="SWITCH"><div class="titre2">SWITCH, CASE, BREAK, DEFAULT, ENDSWITCH</div>
				La syntaxe est une mimic du case en C, avec la particularité de pouvoir écrire plusieurs CASE qui ont la même valeur, ce qui donne plus de souplesse au code conditionnel.<br><br>

				Dans cet exemple, l'appel de la macro avec 5 assemblera toutes les chaines de defb avec 'oui' ou 'encore oui':<br>
				<code>
					macro ouioui mavar<br>
					switch {mavar}<br>
					nop ; pas assemblé car hors case<br>
					case 3<br>
					defb 'non'<br>
					case 5<br>
					defb 'oui'<br>
					case 7<br>
					defb 'encore oui'<br>
					break<br>
					case 8<br>
					defb 'non'<br>
					case 5<br>
					defb 'encore oui'<br>
					break<br>
					default<br>
					defb 'non'<br>
					endswitch<br>
					mend<br>
				</code>
			</div>
			<div id="WHILE"><div class="titre2">WHILE, WEND</div>
				Répète un bloc d'instructions tant que la condition est vérifiée. Il est possible de consulter à tout moment la variable WHILE_COUNTER pour déclencher des évènements en fonction du numéro d'itération.<br><br>

				Exemple:<br>
				<code>
					cpt=10<br>
					while cpt&gt;0<br>
					ldi<br>
					cpt=cpt-1<br>
					print 'cpt=',cpt,' while_counter=',while_counter<br>
					wend<br>
				</code>
				La boucle sera exécutée 10 fois de suite produisant la sortie texte suivante:<br>
				<code>
					Pre-processing [while.asm]<br>
					Assembling<br>
					cpt= 9.00  while_counter= 1.00<br>
					cpt= 8.00  while_counter= 2.00<br>
					cpt= 7.00  while_counter= 3.00<br>
					cpt= 6.00  while_counter= 4.00<br>
					cpt= 5.00  while_counter= 5.00<br>
					cpt= 4.00  while_counter= 6.00<br>
					cpt= 3.00  while_counter= 7.00<br>
					cpt= 2.00  while_counter= 8.00<br>
					cpt= 1.00  while_counter= 9.00<br>
					cpt= 0.00  while_counter= 10.00<br>
					Write binary file rasmoutput.bin (20 bytes)<br>
				</code>
			</div>
		</div>

		<div id="DirectivesF"><div class="titre1">Directives de sortie fichier</div>
			<div id="AMSDOS"><div class="titre2">AMSDOS</div>
				Ajoute un entête Amsdos au fichier binaire produit automatiquement par Rasm. Cet entête n'est pas ajouté lors d'un SAVE. La fonction SAVE dispose elle aussi d’une option pour ajouter cet entête à la demande.
			</div>
			<div id="BREAKPOINT"><div class="titre2">BREAKPOINT [&lt;adresse&gt;]</div>
				Ajoute un point d'arrêt (ce n'est pas une instruction qui est assemblée) avec pour adresse de break l'adresse de l'instruction suivante ou celle du paramètre optionnel. Les points d'arrêt peuvent être exportés sous forme de fichier brut ou dans les snapshots (compatible avec les émulateurs ACE et Winape).<br><br>

				Note: Tout label qui commence par le préfixe BRK ou @BRK génère à la fois un label et un point d'arrêt.<br><br>
			</div>
			<div id="BUILDCPR"><div class="titre2">BUILDCPR</div>
				La directive n'a plus d'utilité. Elle était supposée forcer l'écriture d'une cartouche lorsqu'on cumulait les différents types de sauvegarde.
			</div>
			<div id="BUILDSNA"><div class="titre2">BUILDSNA [V2]</div>
				L'usage de la directive BUILDSNA indique à Rasm qu'on veut générer un snapshot et non une cartouche (dans le doute c'est une cartouche qui est générée).<br><br>

				Par défaut le snapshot est initialisé avec un 6128 CRTC 0 mais il est possible avec les directives <a href=#SETCRTC">SETCRTC</a> et <a href="#SETCPC">SETCPC</a> de choisir un autre type de CPC et de CRTC.<br><br>

				Le snapshot généré par Rasm inclu un écran de taille classique (le même que sous Basic), les encres sont aux valeurs par défaut du Basic (non clignottantes). Les 3 voies audio sont désactivées, les roms désactivées et le mode d'interruption est 1.<br><br>
				
				Exemple:<br>
				<code>
					buildsna ; il est conseillé de commencer par déclarer le SNA pour<br>
					; éviter d'avoir un problème de limite à 512K<br>
					<br>
					bankset 0 ; assembler dans les premiers 64K de la machine<br>
					org #1000<br>
					run #1000 ; le snapshot s'exécutera en #1000<br>
					<br>
					ld b,#7F<br>
					ld a,{page}mydata ; récupère l'ordre gate array de pagination mémoire<br>
					out (c),c<br>
					ld a,(mydata)<br>
					jr $<br>
					<br>
					bank 6 ; choisir la troisième bank du deuxième jeu de 64K<br>
					nop<br>
					mydata defb #DD<br>
					<br>
					bank ; sans paramètre, créer un espace mémoire indépendant qui ne<br>
					; sera pas enregistré dans le snapshot<br>
					<br>
					pouet<br>
					repeat 10<br>
					cpi<br>
					rend<br>
					camion<br>
					save"autrechose",pouet,camion-pouet<br>
				</code>
				<br>
				Option de compatibilité pour la création de snapshot version 2: Certains émulateurs ou cartes hardware ne gèrent pas encore le format v3. Pour rétrograder les snapshots en format v2 (128K maximum, non compressés), il suffit d'ajouter le paramètre V2 après la directive comme suit:<br>
				<code>
					buildsna v2<br>
				</code>
			</div>
			<div id="RUN"><div class="titre2">RUN &lt;adresse&gt;[,&lt;gate array configuration&gt;]</div>
				Cette directive n'est prise en compte que si on génère un snapshot. Alors l'adresse de démarrage du code sera injectée dans le snapshot. En option on peut spécifier la configuration du gate array, typiquement pour exécuter un programme depuis les 64K de mémoire étendue.
			</div>
			<div id="SAVE"><div class="titre2">SAVE 'nom de fichier',&lt;adresse&gt;,&lt;taille&gt;[,AMSDOS|DSK[,'fichier dsk'[,&lt;face&gt;]]]</div>
				Enregistre un fichier binaire à partir de la mémoire adresse jusqu'à adresse+taille de l'espace mémoire en cours. Bien que l'instruction SAVE puisse être déclarée à n'importe quel moment, les enregistrements de fichier sont toujours réalisés en fin d'assemblage si et seulement si il n'y a pas eu d'erreur. Il n'est donc pas possible d'enregistrer des états intermédiaires d'assemblage.<br><br>

				Lorsqu'on enregistre sur une image de disquette (DSK), le nom du fichier binaire est automatiquement tronqué et mis en majuscule si il n'est pas conforme aux limitations de l'AMSDOS.<br><br>

				Exemples:<br>
				<code>
					SAVE 'monfichier.bin',debut,taille ; Enregistrer un fichier binaire brut<br>
					SAVE 'monfichier.bin',debut,taille,AMSDOS ; Enregistrer un fichier binaire avec entête AMSDOS<br>
					SAVE 'monfic.bin',debut,taille,DSK,'fichierdsk.dsk' ; Enregistrer un fichier binaire sur une image de disquette<br>
				</code>


			</div>
			<div id="SETCPC"><div class="titre2">SETCPC &lt;modèle&gt;</div>
				Choisir le modèle de CPC quand on enregistre un snapshot. Les valeurs autorisées sont:<br>
				<ul>
					<li>0 : CPC 464</li>
					<li>1 : CPC 664</li>
					<li>2 : CPC 6128</li>
					<li>4 : 464 Plus</li>
					<li>5 : 6128 Plus</li>
					<li>6 : GX-4000</li>
				</ul>
			</div>
			<div id="SETCRTC"><div class="titre2">SETCRTC &lt;modèle&gt;</div>
				Choisir le modèle de CRTC quand on enregistre un snapshot. Les valeurs autorisées vont de 0 à 4. Pour rappel, les CPC ont des CRTC 0,1,2 ou 4 et les Plus ou GX-4000 ont tous le CRTC 3.
			</div>
		</div>

		<div id="DirectivesU"><div class="titre1">Directives de compatibilité</div>
			<div id="LIST"><div class="titre2">LIST, NOLIST, LET</div>
				Directives ignorées, pour compatibilité avec Winape.
			</div>
		</div>


		<div id="Instructions"><div class="titre1">Jeu d'instruction</div>
			Toutes les instructions documentées et non documentées sont supportées.<br><br>

			L'adressage 8 bits des registres d'index IX et IY se fait indifféremment avec LX, IXL ou XL, etc.<br><br>

			Les instructions complexes s'écrivent de la façon suivante:<br>
			<code>
				res 0,(ix+0),a<br>
				bit 0,(ix+0),a<br>
				sll 0,(ix+0),a<br>
				rl  0,(ix+0),a<br>
				rr  0,(ix+0),a<br>
			</code>
			<br>
			Syntaxes des instructions non documentées:<br>
			<code>
				out (#12),a ; #12 peut être n'importe quelle valeur 8 bits<br>
				in a,(#12)<br>
				in 0,(c) ou in f,(c)<br>
				sll &lt;registre&gt; ou sl1 &lt;registre&gt;<br>
			</code>
			<br>
			Syntaxes spéciales autorisées:<br>
			- PUSH multi-arguments<br>
			<code>
				push bc,de,hl ; &rarr; push bc : push de : push hl<br>
			</code>
			- NOP répétitif<br>
			<code>
				nop 4         ; &rarr; nop : nop : nop : nop<br>
			</code>
			- complex LD<br>
			<code>
				LD BC,BC      ; &rarr; LD B,B : LD C,C<br>
				LD BC,DE      ; &rarr; LD B,D : LD C,E<br>
				LD BC,HL      ; &rarr; LD B,H : LD C,L<br>
				LD DE,BC      ; &rarr; LD D,B : LD E,C<br>
				LD DE,DE      ; &rarr; LD D,D : LD E,E<br>
				LD DE,HL      ; &rarr; LD D,H : LD E,L<br>
				LD HL,BC      ; &rarr; LD H,B : LD L,C<br>
				LD HL,DE      ; &rarr; LD H,D : LD L,E<br>
				LD HL,HL      ; &rarr; LD H,H : LD L,L<br>
				<br>
				LD HL,(IX+n) ; &rarr; LD H,(IX+n+1) : LD L,(IX+n)<br>
				LD HL,(IY+n) ; &rarr; LD H,(IY+n+1) : LD L,(IY+n)<br>
				LD DE,(IX+n) ; &rarr; LD D,(IX+n+1) : LD E,(IX+n)<br>
				LD DE,(IY+n) ; &rarr; LD D,(IY+n+1) : LD E,(IY+n)<br>
				LD BC,(IX+n) ; &rarr; LD B,(IX+n+1) : LD C,(IX+n)<br>
				LD BC,(IY+n) ; &rarr; LD B,(IY+n+1) : LD C,(IY+n)<br>
				<br>
				LD (IX+n),HL ; &rarr; LD (IX+n+1),H : LD (IX+n),L<br>
				LD (IY+n),HL ; &rarr; LD (IY+n+1),H : LD (IY+n),L<br>
				LD (IX+n),DE ; &rarr; LD (IX+n+1),D : LD (IX+n),E<br>
				LD (IY+n),DE ; &rarr; LD (IY+n+1),D : LD (IY+n),E<br>
				LD (IX+n),BC ; &rarr; LD (IX+n+1),B : LD (IX+n),C<br>
				LD (IY+n),BC ; &rarr; LD (IY+n+1),B : LD (IY+n),C<br>
			</code>
		</div>

		<div id="Limitations"><div class="titre1">Limitations</div>
			<ul>
				<li>Il n'est pas possible d'utiliser la mnémonique d'une instruction Z80 comme un label.</li>
				<li>Il n'est pas possible d'utiliser le même nom pour un label, une variable ou un alias.</li>
				<li>Rasm n'est pas sensible à la casse.</li>
				<li>Les blocs de code à compresser dynamiquement ne peuvent excéder 64K.</li>
			</ul>
		</div>

		<div id="licence">
			Ce logiciel et sa documentation utilisent la licence <a href="https://fr.wikipedia.org/wiki/Licence_MIT" target=_top>MIT</a> &quot;expat&quot;<br><br>

			&laquo; Copyright &copy; BERG&Eacute; &Eacute;douard (roudoudou)<br><br>

			Permission  is  hereby  granted,  free  of charge, to any person obtaining a copy  of  this  software and  associated  documentation/source   files   of RASM, to deal in the Software without restriction, including without limitation the  rights  to  use, copy,   modify,   merge,   publish,    distribute, sublicense,  and/or  sell  copies of the Software, and  to  permit  persons  to  whom the Software is furnished  to  do  so,  subject  to  the following conditions:<br><br>

			The above copyright  notice  and  this  permission notice   shall   be  included  in  all  copies  or substantial portions of the Software. The   Software   is   provided  &quot;as is&quot;,   without warranty   of   any   kind,  express  or  implied, including  but  not  limited  to the warranties of merchantability,   fitness   for   a    particular purpose  and  noninfringement.  In  no event shall the  authors  or  copyright  holders be liable for any  claim, damages  or other  liability,  whether in  an  action  of  contract, tort  or  otherwise, arising from,  out of  or in connection  with  the software  or  the  use  or  other  dealings in the Software. &raquo;
		</div>
		
	</div>
	</body>
</html>
